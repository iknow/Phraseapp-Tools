#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require 'phraseapp_updater'

class PhraseAppUpdaterCLI < Thor
  class_option :default_locale, type: :string, default: 'en',   desc: 'PhraseApp default locale'
  class_option :file_format,    type: :string, default: 'json', desc: "Filetype of localization files."

  desc 'setup <locale_path>',
       'Create a new PhraseApp project, initializing it with locale files at <locale_path>. the new project ID is printed to STDOUT'
  method_option :phraseapp_api_key,      type: :string, required: true, desc: "PhraseApp API key."
  method_option :phraseapp_project_name, type: :string, required: true, desc: "Name for new PhraseApp project."

  def setup(locales_path)
    validate_readable_path!('locales', locales_path)

    handle_errors do
      updater, project_id = PhraseAppUpdater.for_new_project(
                 options[:phraseapp_api_key],
                 options[:phraseapp_project_name],
                 options[:file_format])

      updater.upload_directory(locales_path)
      puts project_id
    end
  end

  desc 'download <target_path>',
       'Download and renormalize locale files from PhraseApp to <target_path>'
  method_option :phraseapp_api_key,    type: :string, required: true, desc: "PhraseApp API key."
  method_option :phraseapp_project_id, type: :string, required: true, desc: "PhraseApp project ID."
  def download(target_path)
    phraseapp_api_key = options[:phraseapp_api_key]
    phraseapp_project_id = options[:phraseapp_project_id]
    validate_writable_path!('target path', target_path)

    handle_errors do
      updater = PhraseAppUpdater.new(phraseapp_api_key, phraseapp_project_id, file_format)
      updater.download_to_directory(target_path)
    end
  end

  desc 'upload <locale_path>',
       'Renormalize and upload locale files at <locale_path> to PhraseApp, replacing current contents.'
  method_option :phraseapp_api_key,    type: :string, required: true, desc: "PhraseApp API key."
  method_option :phraseapp_project_id, type: :string, required: true, desc: "PhraseApp project ID."
  def upload(source_path)
    phraseapp_api_key = options[:phraseapp_api_key]
    phraseapp_project_id = options[:phraseapp_project_id]
    validate_readable_path!('source path', source_path)

    handle_errors do
      updater = PhraseAppUpdater.new(phraseapp_api_key, phraseapp_project_id, file_format)
      updater.upload_directory(source_path)
    end
  end

  desc 'merge <ancestor_path> <our_path> <their_path>',
       '3-way merge locale file directories <ancestor_path>, <our_path>, <their_path> into TO.'

  long_desc <<-LONGDESC
    Perform a JSON-aware 3-way merge of locale files in directories <ancestor_path>, <our_path>, <their_path> into TO.

    The merge resolution strategy always selects `ours` in the case of a conflict.
  LONGDESC

  method_option :to, type: :string, required: true, desc: 'Target directory'

  def merge(ancestor_path, our_path, their_path)
    validate_readable_path!('ancestor_path', ancestor_path)
    validate_readable_path!('our_path', our_path)
    validate_readable_path!('their_path', their_path)

    result_path = options[:to]
    validate_writable_path!('to', result_path)

    handle_errors do
      updater = PhraseAppUpdater.new(nil, nil, file_format)
      updater.merge_directories(our_path, their_path, ancestor_path, result_path)
    end
  end

  desc 'merge_file <ancestor> <ours> <theirs>',
       'Perform 3-way merge of a single file into TO'

  long_desc <<-LONGDESC
    Perform 3-way merge of a single file into TO

    Intended for use as a git merge-driver with:
      [merge "phraseapp-locale"]
        name = PhraseApp locale file merge driver
        driver = phraseapp_updater merge_file %O %A %B --to %P
  LONGDESC

  method_option :to, type: :string, required: true, desc: 'Target file'

  def merge_file(ancestor, ours, theirs)
    validate_readable_file!('ancestor', ancestor)
    validate_readable_file!('ours', ours)
    validate_readable_file!('theirs', theirs)
    validate_writable_file!('to', to)

    # Git provides an empty file when there is no common ancestor in the
    # merge-base. Because we want to merge from an empty hash structure instead,
    # pass `nil` to `merge_files`.
    ancestor = nil if File.zero?(ancestor)

    updater = PhraseAppUpdater.new(nil, nil, file_format)
    updater.merge_files(ours, theirs, ancestor, to)
  end

  desc "default", "Prints gem information"
  option :version, aliases: [:v]

  def default
    if options[:v] || options[:version]
      puts PhraseAppUpdater::VERSION
    else
      help
    end
  end

  default_command :default

  private

  def handle_errors
    yield
  rescue PhraseAppUpdater::PhraseAppAPI::BadAPIKeyError => _e
    STDERR.puts "Bad PhraseApp API key."
    exit(1)
  rescue PhraseAppUpdater::PhraseAppAPI::BadProjectIDError => _e
    STDERR.puts "Bad PhraseApp project ID: #{e.project_id}"
    exit(1)
  rescue PhraseAppUpdater::PhraseAppAPI::ProjectNameTakenError => _e
    STDERR.puts "PhraseApp project name already taken: #{options[:phraseapp_project_name]}"
    exit(1)
  rescue PhraseAppUpdater::LocaleFile::BadFileTypeError => e
    STDERR.puts "Bad filetype for localization files: #{e.message}"
    exit(1)
  rescue StandardError => e
    STDERR.puts "Unknown error when pushing files."
    raise e
  end

  def validate_readable_file!(name, file)
    unless File.readable?(file) && File.file?(file)
      raise RuntimeError.new("#{name} is not a readable file: #{file}")
    end
  end

  def validate_writable_file!(name, file)
    unless File.writable?(file) && File.file?(file)
      raise RuntimeError.new("#{name} is not a writable file: #{file}")
    end
  end

  def validate_path!(name, path)
    if path.empty?
      raise RuntimeError.new("#{name} was empty.")
    end
  end

  def validate_readable_path!(name, path)
    validate_path!(name, path)

    unless File.readable?(path) && File.directory?(path)
      raise RuntimeError.new("#{name} path is not a readable directory: #{path}")
    end
  end

  def validate_writable_path!(name, path)
    validate_path!(name, path)

    unless File.writable?(path) && File.directory?(path)
      raise RuntimeError.new("#{name} path is not a writable directory: #{path}")
    end
  end
end

PhraseAppUpdaterCLI.start(ARGV)
