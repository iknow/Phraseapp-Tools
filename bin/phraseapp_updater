#!/usr/bin/env ruby
require 'thor'
require 'phraseapp_updater'

class PhraseAppUpdaterCLI < Thor
  desc "push", "Update PhraseApp project via a 3-way merge with local locale files and PhraseApp data."
  option :new_locales_path,                type: :string, desc: "Path to newest revision of local files. Shell variable: PA_NEW_LOCALES_PATH"
  option :previous_locales_path,           type: :string, desc: "Path to previous revision of local files. Shell variable: PA_PREVIOUS_LOCALES_PATH"
  option :phraseapp_api_key,               type: :string, desc: "PhraseApp API key. Shell variable: PA_API_KEY"
  option :phraseapp_project_id,            type: :string, desc: "PhraseApp project ID. Shell variable: PA_PROJECT_ID"
  option :config_file_path,                type: :string, desc: "Path to .phraseapp.yml config file to read API key and project ID."
  option :store_results_path,              type: :string, desc: "Path to write the resolved files. Shell variable: PA_STORE_RESULTS_PATH"
  option :store_phraseapp_originals_path,  type: :string, desc: "Path to write the files downloaded from PhraseApp before the merge. Shell variable: PA_STORE_PHRASEAPP_ORIGINALS_PATH"
  option :file_format,                     type: :string, desc: "Filetype of localization files. Shell variable: PA_FILE_FORMAT"

  def push
    phraseapp_api_key, phraseapp_project_id, file_format = load_phraseapp_configuration(options)

    new_locales_path = options.fetch(:new_locales_path, ENV["PA_NEW_LOCALES_PATH"]).to_s
    validate_readable_path!('new_locales_path', new_locales_path)

    previous_locales_path = options.fetch(:previous_locales_path, ENV["PA_PREVIOUS_LOCALES_PATH"]).to_s
    validate_readable_path!('previous_locales_path', previous_locales_path)

    store_results_path = options.fetch(:store_results_path, ENV["PA_STORE_RESULTS_PATH"]).to_s
    validate_writable_path!('store_results_path', store_results_path)

    store_phraseapp_originals_path = options.fetch(:store_phraseapp_originals_path, ENV["PA_STORE_PHRASEAPP_ORIGINALS_PATH"]).to_s
    validate_writable_path!('store_phraseapp_originals_path', store_phraseapp_originals_path)

    begin
      result = PhraseAppUpdater.new(phraseapp_api_key, phraseapp_project_id, file_format).push(previous_locales_path, new_locales_path)

      unless store_results_path.empty?
        write_locale_files(store_results_path, result.resolved_files)
      end

      unless store_phraseapp_originals_path.empty?
        write_locale_files(store_phraseapp_originals_path, result.original_phraseapp_files)
      end
    rescue PhraseAppUpdater::PhraseAppAPI::BadAPIKeyError => e
      STDERR.puts "Bad PhraseApp API key."
      exit(1)
    rescue PhraseAppUpdater::PhraseAppAPI::BadProjectIDError => e
      STDERR.puts "Bad PhraseApp project ID: #{phraseapp_project_id}"
      exit(1)
    rescue PhraseAppUpdater::LocaleFile::BadFileTypeError => e
      STDERR.puts "Bad filetype for localization files: #{e.message}"
      exit(1)
    rescue StandardError => e
      STDERR.puts "Unknown error when pushing files."
      raise e
    end
  end

  desc "setup", "Create a new PhraseApp project, initializing it with provided locale files. The new project ID is printed to STDOUT"
  option :new_locales_path,       type: :string, desc: "Path to newest revision of local files. Shell variable: PA_NEW_LOCALES_PATH"
  option :phraseapp_api_key,      type: :string, desc: "PhraseApp API key. Shell variable: PA_API_KEY"
  option :phraseapp_project_name, type: :string, desc: "PhraseApp project ID. Shell variable: PA_PROJECT_NAME"
  option :file_format,            type: :string, desc: "Filetype of localization files. Shell variable: PA_FILE_FORMAT"

  def setup
    phraseapp_project_name = options.fetch(:phraseapp_project_name, ENV["PA_PROJECT_NAME"]).to_s
    phraseapp_api_key      = options.fetch(:phraseapp_api_key, ENV["PA_API_KEY"]).to_s
    file_format            = options.fetch(:file_format, ENV["PA_FILE_FORMAT"]).to_s

    if phraseapp_api_key.empty?
      raise RuntimeError.new("Must provide Phraseapp API key. --phraseapp_api_key or PA_API_KEY")
    end

    if phraseapp_project_name.empty?
      raise RuntimeError.new("Must provide Phraseapp project name. --phraseapp_project_name or PA_PROJECT_NAME")
    end

    if file_format.empty?
      raise RuntimeError.new("Must provide file format for Phraseapp project. --file_format or PA_FILE_FORMAT")
    end

    new_locales_path = options.fetch(:new_locales_path, ENV["PA_NEW_LOCALES_PATH"]).to_s
    validate_readable_path!('new_locales_path', new_locales_path)

    begin
      updater, project_id = PhraseAppUpdater.for_new_project(phraseapp_api_key, phraseapp_project_name, file_format)
      updater.initial_push(new_locales_path)
      puts project_id
    rescue PhraseAppUpdater::PhraseAppAPI::BadAPIKeyError => _e
      STDERR.puts "Bad PhraseApp API key."
      exit(1)
    rescue PhraseAppUpdater::PhraseAppAPI::BadProjectIDError => _e
      STDERR.puts "Bad PhraseApp project ID: #{project_id}"
      exit(1)
    rescue PhraseAppUpdater::PhraseAppAPI::ProjectNameTakenError => _e
      STDERR.puts "PhraseApp project name already taken: #{phraseapp_project_name}"
      exit(1)
    rescue PhraseAppUpdater::LocaleFile::BadFileTypeError => e
      STDERR.puts "Bad filetype for localization files: #{e.message}"
      exit(1)
    rescue StandardError => e
      STDERR.puts "Unknown error when pushing files."
      raise e
    end
  end

  desc "pull", "Pulls data from PhraseApp for deployment, replacing missing keys from fallback."
  option :fallback_path,         type: :string,  required: true, desc: "Path to the files to restore missing keys from."
  option :destination_path,      type: :string,                  desc: "Path to write the resolved files to. If not provided, --fallback_path is used."
  option :phraseapp_api_key,     type: :string,                  desc: "PhraseApp API key. Shell variable: PA_API_KEY"
  option :phraseapp_project_id,  type: :string,                  desc: "PhraseApp project ID. Shell variable: PA_PROJECT_ID"
  option :config_file_path,      type: :string,                  desc: "Path to .phraseapp.yml config file to read API key and project ID."
  option :file_format,           type: :string,                  desc: "Filetype of localization files. Shell variable: PA_FILE_FORMAT"

  def pull
    phraseapp_api_key, phraseapp_project_id, file_format = load_phraseapp_configuration(options)

    fallback_path = options[:fallback_path]
    validate_readable_path!('fallback_path', fallback_path)

    destination_path = options.fetch(:destination_path, fallback_path).to_s
    validate_writable_path!('destination_path', destination_path)

    begin
      files = PhraseAppUpdater.new(phraseapp_api_key, phraseapp_project_id, file_format).pull(fallback_path)
      write_locale_files(destination_path, files)
    rescue PhraseAppUpdater::PhraseAppAPI::BadAPIKeyError => e
      STDERR.puts "Bad PhraseApp API key."
      exit(1)
    rescue PhraseAppUpdater::PhraseAppAPI::BadProjectIDError => e
      STDERR.puts "Bad PhraseApp project ID: #{phraseapp_project_id}"
      exit(1)
    rescue PhraseAppUpdater::LocaleFile::BadFileTypeError => e
      STDERR.puts "Bad filetype for localization files: #{e.message}"
      exit(1)
    rescue StandardError => e
      STDERR.puts "Unknown error when pulling files"
      raise e
    end
  end

  desc "default", "Prints gem information"
  option :version, aliases: [:v]

  def default
    if options[:v] || options[:version]
      puts PhraseAppUpdater::VERSION
    else
      help
    end
  end

  default_command :default

  private

  def load_phraseapp_configuration(options)
    if options[:config_file_path]
      if [:phraseapp_api_key, :phraseapp_project_id, :phraseapp_project_name, :file_format].any? { |option| options.has_key?(option) }
        raise RuntimeError.new("Provided both a path to PhraseApp config file and command line arguments. Specify only one. #{options}")
      end

      config = PhraseAppUpdater.load_config(options[:config_file_path])

      phraseapp_api_key    = config.api_key
      phraseapp_project_id = config.project_id
      file_format          = config.file_format
    else
      phraseapp_api_key    = options.fetch(:phraseapp_api_key, ENV["PA_API_KEY"]).to_s
      phraseapp_project_id = options.fetch(:phraseapp_project_id, ENV["PA_PROJECT_ID"]).to_s
      file_format          = options.fetch(:file_format, ENV["PA_FILE_FORMAT"]).to_s
    end

    if phraseapp_api_key.empty?
      raise RuntimeError.new("Must provide Phraseapp API key. --phraseapp_api_key or PA_API_KEY")
    end

    if phraseapp_project_id.empty?
      raise RuntimeError.new("Must provide Phraseapp project ID. --phraseapp_project_id or PA_PROJECT_ID")
    end

    if file_format.empty?
      raise RuntimeError.new("Must provide file format for Phraseapp project. --file_format or PA_FILE_FORMAT")
    end

    return [phraseapp_api_key, phraseapp_project_id, file_format]
  end

  def validate_path!(name, path)
    if path.empty?
      raise RuntimeError.new("#{name} was empty.")
    end
  end

  def validate_readable_path!(name, path)
    validate_path!(name, path)

    unless File.readable?(path) && File.directory?(path)
      raise RuntimeError.new("#{name} path is not a readable directory: #{path}")
    end
  end

  def validate_writable_path!(name, path)
    validate_path!(name, path)

    unless File.writable?(path) && File.directory?(path)
      raise RuntimeError.new("#{name} path is not a writable directory: #{path}")
    end
  end

  def write_locale_files(path, files)
    files.each do |file|
      full_path = "#{path.chomp('/')}/#{file.name_with_extension}"
      File.write(full_path, file.content)
    end
    puts "Wrote #{files.count} files to #{path}: #{files.map(&:name_with_extension)}"
  end
end

PhraseAppUpdaterCLI.start(ARGV)

